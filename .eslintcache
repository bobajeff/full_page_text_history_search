[{"/home/bobajeff/page_search/page_finder_frontend/src/index.js":"1","/home/bobajeff/page_search/page_finder_frontend/src/App.js":"2","/home/bobajeff/page_search/page_finder_frontend/src/searchbar.js":"3","/home/bobajeff/page_search/page_finder_frontend/src/trackscroll.js":"4","/home/bobajeff/page_search/page_finder_frontend/src/search.js":"5","/home/bobajeff/page_search/page_finder_frontend/src/date_format.js":"6"},{"size":221,"mtime":1609374176197,"results":"7","hashOfConfig":"8"},{"size":2626,"mtime":1609388756159,"results":"9","hashOfConfig":"8"},{"size":3373,"mtime":1609374176201,"results":"10","hashOfConfig":"8"},{"size":757,"mtime":1609375874621,"results":"11","hashOfConfig":"8"},{"size":6364,"mtime":1609377340097,"results":"12","hashOfConfig":"8"},{"size":541,"mtime":1609387723589,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"1nja2ba",{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"16"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"/home/bobajeff/page_search/page_finder_frontend/src/index.js",[],["28","29"],"/home/bobajeff/page_search/page_finder_frontend/src/App.js",[],"/home/bobajeff/page_search/page_finder_frontend/src/searchbar.js",[],"/home/bobajeff/page_search/page_finder_frontend/src/trackscroll.js",[],"/home/bobajeff/page_search/page_finder_frontend/src/search.js",["30"],"import MeiliSearch from \"meilisearch\";\n\nvar index;\nexport async function initIndex(){\n    let client = new MeiliSearch({\n        host: \"http://127.0.0.1:7700/\",\n        apiKey: \"masterKey\"\n      });\n    \n    index = await client.getIndex(\"pages\");\n}\n\nvar lastsearch = \"\";\nvar offset = 0;\n\nexport function highlightTokens(hit){\n  const character_limit = 140;\n  var text = hit.text;\n  var substrings_info = [];\n  var elements = [];\n  if (!!hit._matchesInfo && !!hit._matchesInfo.text && !!hit._matchesInfo.text.length)\n  {\n    hit._matchesInfo.text.forEach((match)=>{\n            var{start, length} = match;\n            \n            \n            if(length < character_limit) //Check if matched text take up character limit\n            {\n                let context = character_limit - length;\n                var context_limit = Math.floor(context / 2);\n                // var begin = start - context_limit;\n                //begin context\n                \n                //check that there is a previous substring info entry\n                if (substrings_info.length !== 0)\n                {\n                    var previous_substring_info_index = substrings_info.length -1;\n                    const begin = start - context_limit;\n                    //check if the begin context overlaps the previous substring\n                    if (begin < substrings_info[previous_substring_info_index].end)\n                    {\n                        //if previous substring overlaps make don't bother with beginning context\n                        if (!substrings_info[previous_substring_info_index].highlighted)\n                        {\n                            \n                            substrings_info[previous_substring_info_index].end = start;\n                            substrings_info[previous_substring_info_index].end_elipses = false;\n                            \n                        }\n                        else //if not just change the begin to start at the previous end\n                        {\n                            substrings_info.push({begin: substrings_info[previous_substring_info_index].end, end: start});\n                            substrings_info[previous_substring_info_index].end_elipses = false;\n                        }\n                    }\n                    //check if the begin context underflows the string\n                    else if (begin <= 0 )\n                    {\n                        substrings_info.push({begin: 0, end: start});\n                    }\n                    else\n                    {\n                        substrings_info.push({begin: begin, end: start}); // in this case we wont need the elipses since the previous snippet ha one\n                    }\n\n                }\n                else //if no previous substring info entry \n                {\n                    var begin = start - context_limit;\n                    //check if the begin context underflows the string\n                    if (begin <= 0 )\n                    {\n                        substrings_info.push({begin: 0, end: start});\n                    }\n                    else\n                    {\n                        substrings_info.push({begin: begin, end: start, begin_elipses: true});\n                    }\n                }\n\n\n                //highlighted\n                substrings_info.push({begin: start, end: start+length, highlighted: true});\n\n\n                //end_context\n                const cut_off = start+length+context_limit;\n                //check if cut_off is more than string length\n                if (cut_off > (text.length -1))\n                {\n                    //if it is use the string lenth as cutoff\n                    substrings_info.push({begin: start+length, end: (text.length -1)});\n                }\n                else\n                {\n                    substrings_info.push({begin: start+length, end: cut_off, end_elipses: true});\n                }\n            }\n            else //if matched text is over character limit don't bother with context\n            {\n                //no context budget left\n                //highlighted\n                if (substrings_info.length !== 0)\n                {\n                    var previous_substring_info_index = substrings_info.length -1;\n                    if (start === substrings_info[previous_substring_info_index].end)\n                    {\n                        substrings_info.push({begin: start, end: start+length, highlighted: true, end_elipses: true});\n                    }\n                    else\n                    {\n                        substrings_info.push({begin: start, end: start+length, highlighted: true, begin_elipses: true, end_elipses: true});\n                    }\n                }\n                else\n                {\n                    substrings_info.push({begin: start, end: start+length, highlighted: true, end_elipses: true, begin_elipses: true});\n                }\n            }\n    });\n\n    substrings_info.forEach((substring_info)=>{\n        let {begin, end} = substring_info;\n        if (!!substring_info.begin_elipses)\n        {\n            elements.push(<em>...</em>);\n        }\n        if ((!!substring_info.highlighted))\n        {\n            elements.push(<mark>{text.substring(begin, end)}</mark>);\n        }\n        else\n        {\n          elements.push(text.substring(begin, end));\n        }\n        if (!!substring_info.end_elipses)\n        {\n            elements.push(<em>...</em>);\n        }\n    });\n    return elements;\n  }\n  else\n  {\n    return \"\";\n  }\n}\n\nasync function Search(searchtext){\n    if (!index)\n    {\n        await initIndex();\n    }\n    \n    async function searchWithMeili(searchtext) {\n        offset = 0;\n        lastsearch = searchtext;\n        var searchfilter = {\n          matches: true\n        }\n      const search = await index.search(searchtext, searchfilter);\n        return search.hits;\n    }\n    let results = await searchWithMeili(searchtext);\n    \n    \n\n      return results;\n}\n\nexport async function LoadMoreHits()\n{\n    var searchfilter = {\n        matches: true,\n        offset: offset\n      }\n    const results = await index.search(lastsearch, searchfilter);\n    offset = offset + 20;\n    if (results.hits.length !== 0)\n    {\n        return results.hits;\n    }\n    else\n    {\n        return 0;\n    }\n\n}\n\nexport default Search;","/home/bobajeff/page_search/page_finder_frontend/src/date_format.js",[],{"ruleId":"31","replacedBy":"32"},{"ruleId":"33","replacedBy":"34"},{"ruleId":"35","severity":1,"message":"36","line":105,"column":25,"nodeType":"37","messageId":"38","endLine":105,"endColumn":54},"no-native-reassign",["39"],"no-negated-in-lhs",["40"],"no-redeclare","'previous_substring_info_index' is already defined.","Identifier","redeclared","no-global-assign","no-unsafe-negation"]